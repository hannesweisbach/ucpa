/* vi: set filetype=cpp : */
#pragma once

#include <typeinfo>
#include <memory>

namespace upca {
class any final {
    struct concept {
      virtual ~concept() = default;
      virtual const std::type_info &type() const noexcept = 0;
    };

    template <typename T> class model : public concept {
      T data_;

    public:
      model(T &&data) : data_(std::move(data)) {}
      model(const T &data) : data_(data) {}

      const std::type_info &type() const noexcept override  {
        return typeid(data_);
      }

      const T &get() const { return data_; }
    };

    std::unique_ptr<concept> storage_;

    template <typename ValueType> friend ValueType any_cast(const any &operand);

  public:
    template <typename ValueType,
              typename = typename std::enable_if<!std::is_same<
                  typename std::decay<ValueType>::type, any>::value>::type>
    any(ValueType &&value)
        : storage_(std::make_unique<model<typename std::decay<ValueType>::type>>(
              std::forward<ValueType>(value))) {}

    bool is_type(const std::type_info &ti) const {
      return ti == storage_->type();
    }
};

template <typename T> struct a;
template <typename ValueType> ValueType any_cast(const any &operand) {
  if (!operand.is_type(typeid(ValueType))) {
    throw std::runtime_error("bad any cast");
  }

  return static_cast<const any::model<typename std::decay<ValueType>::type> &>(
             *operand.storage_)
      .get();
}
} // namespace upca
